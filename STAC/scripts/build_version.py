#!/usr/bin/env python3
"""
Generate build version information automatically during compilation.

This script creates a build_info.h header with:
- Software version (from Device_Config.h)
- Git commit hash (short)
- Git branch name
- Build timestamp
- Source hash (MD5 of src/ and include/ directories)

Called automatically by PlatformIO before compilation.
"""

Import("env")
import hashlib
import subprocess
import os
from datetime import datetime
from pathlib import Path


def get_git_info():
    """Get git commit hash and branch name."""
    try:
        # Get short commit hash (7 chars like GitHub)
        commit = subprocess.check_output(
            ['git', 'rev-parse', '--short=7', 'HEAD'],
            stderr=subprocess.DEVNULL,
            cwd=env.get("PROJECT_DIR")
        ).decode('utf-8').strip()
        
        # Get branch name
        branch = subprocess.check_output(
            ['git', 'rev-parse', '--abbrev-ref', 'HEAD'],
            stderr=subprocess.DEVNULL,
            cwd=env.get("PROJECT_DIR")
        ).decode('utf-8').strip()
        
        # Check if working directory is clean
        status = subprocess.check_output(
            ['git', 'status', '--porcelain'],
            stderr=subprocess.DEVNULL,
            cwd=env.get("PROJECT_DIR")
        ).decode('utf-8').strip()
        
        dirty = '+' if status else ''
        
        return commit, branch, dirty
    except:
        return "unknown", "unknown", ""


def hash_directory(path, extensions=['.cpp', '.h', '.hpp', '.tpp']):
    """
    Generate MD5 hash of source files in directory.
    Only includes specified file extensions.
    """
    hasher = hashlib.md5()
    
    # Walk directory tree
    for root, dirs, files in sorted(os.walk(path)):
        # Skip hidden directories and build artifacts
        dirs[:] = [d for d in dirs if not d.startswith('.') and d not in ['.pio', 'bin']]
        
        for filename in sorted(files):
            if any(filename.endswith(ext) for ext in extensions):
                filepath = os.path.join(root, filename)
                
                # Hash file path (relative to base)
                rel_path = os.path.relpath(filepath, path)
                hasher.update(rel_path.encode('utf-8'))
                
                # Hash file contents
                with open(filepath, 'rb') as f:
                    hasher.update(f.read())
    
    return hasher.hexdigest()


def extract_version_from_config():
    """Extract version string from Device_Config.h."""
    config_path = Path(env.get("PROJECT_DIR")) / "include" / "Device_Config.h"
    
    try:
        with open(config_path, 'r') as f:
            for line in f:
                if '#define STAC_SOFTWARE_VERSION' in line:
                    # Extract quoted string
                    parts = line.split('"')
                    if len(parts) >= 2:
                        return parts[1]
    except:
        pass
    
    return "?.?.?"


def generate_build_info():
    """Generate build_info.h header file."""
    
    project_dir = Path(env.get("PROJECT_DIR"))
    
    # Get version from Device_Config.h
    sw_version = extract_version_from_config()
    
    # Get git information
    git_commit, git_branch, git_dirty = get_git_info()
    
    # Generate source hash (last 6 chars for build number)
    src_path = project_dir / "src"
    include_path = project_dir / "include"
    
    src_hash = hash_directory(src_path)
    include_hash = hash_directory(include_path)
    
    # Combine hashes
    combined = hashlib.md5((src_hash + include_hash).encode('utf-8')).hexdigest()
    build_number = combined[-6:]  # Last 6 characters
    
    # Get build timestamp
    build_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    build_date = datetime.now().strftime("%Y-%m-%d")
    
    # Determine build type from PlatformIO build_type setting
    # PlatformIO has exactly 3 build types: release, debug, test
    build_type = env.get("BUILD_TYPE", "release")  # Default to release if not set
    
    # Map build type to single character
    build_type_map = {
        "debug": "D",
        "release": "R",
        "test": "T"
    }
    build_type_char = build_type_map.get(build_type, "?")
    
    # Extract CORE_DEBUG_LEVEL from build flags
    debug_level = "?"
    build_flags = env.get("BUILD_FLAGS", [])
    for flag in build_flags:
        if isinstance(flag, str) and "CORE_DEBUG_LEVEL=" in flag:
            debug_level = flag.split("=")[1]
            break
    
    # Generate header file
    header_path = project_dir / "include" / "build_info.h"
    
    header_content = f"""// Auto-generated build information
// Generated: {build_time}
// DO NOT EDIT - This file is automatically generated during compilation

#ifndef BUILD_INFO_H
#define BUILD_INFO_H

// Software version (from Device_Config.h)
#define BUILD_VERSION "{sw_version}"

// Git information
#define BUILD_GIT_COMMIT "{git_commit}{git_dirty}"
#define BUILD_GIT_BRANCH "{git_branch}"

// Build number (MD5 hash of source files, last 6 chars)
#define BUILD_NUMBER "{build_number}"

// Build timestamp
#define BUILD_TIMESTAMP "{build_time}"
#define BUILD_DATE "{build_date}"

// Build type and debug level
#define BUILD_TYPE_CHAR "{build_type_char}"
#define BUILD_DEBUG_LEVEL "{debug_level}"

// Full version string with build info
#define BUILD_FULL_VERSION "{sw_version} ({build_number})"

// Detailed build string for debugging
#define BUILD_INFO_STRING "{sw_version} build:{build_number} git:{git_commit}{git_dirty} {build_date}"

#endif // BUILD_INFO_H
"""
    
    # Write header file
    with open(header_path, 'w') as f:
        f.write(header_content)
    
    # Print build info to console
    print("=" * 60)
    print("Build Information Generated:")
    print(f"  Version:      {sw_version}")
    print(f"  Build Number: {build_number}")
    print(f"  Git Commit:   {git_commit}{git_dirty}")
    print(f"  Git Branch:   {git_branch}")
    print(f"  Build Time:   {build_time}")
    print(f"  Build Type:   {build_type_char}")
    print(f"  Debug Level:  {debug_level}")
    print("=" * 60)


# Run before compilation
env.AddPreAction("buildprog", lambda source, target, env: generate_build_info())

# Also run before filesystem image creation (if needed)
env.AddPreAction("buildfs", lambda source, target, env: generate_build_info())
